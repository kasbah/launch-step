#!/usr/bin/env node
'use strict'
const midi          = require('midi')
const midiLaunchpad = require('midi-launchpad')
const argv          = require('argv')
const StepSequencer = require('step-sequencer')
const tonalScale    = require('tonal-scale')
const tonalMidi     = require('tonal-midi')
const tonalRange    = require('tonal-range')
const kebabCase     = require('lodash.kebabcase')
const {noteOn, noteOff} = require('midi-help')

const scaleFromKebab = {}
tonalScale.names().forEach(n => scaleFromKebab[kebabCase(n)] = n)
const supportedScales = Object.keys(scaleFromKebab)

const args = argv.option([
    {
        name: 'tempo',
        short: 't',
        type: 'string',
        description: 'Tempo in steps per minute. The default is 90. Can be set '
            + 'to "ext" to use an external midi clock signal.',
        example: "'launch-step -t 133.2' or 'launch-step --tempo=133.2'"
    },
    {
        name: 'steps',
        short: 's',
        type: 'int',
        description: 'Number of steps in the sequence. The default is 8.',
        example: "'launch-step -s 12' or 'launch-step --steps=12'"
    },
    {
        name: 'rows',
        short: 'r',
        type: 'int',
        description: 'Number of rows i.e. tracks in the sequence. The default '
            + 'is 8.',
        example: "'launch-step -r 12' or 'launch-step --rows=12'"
    },
    {
        name: 'scale',
        short: 'l',
        type: 'string',
        description: `The scale to apply to the rows. The default is `
            + `"major-pentatonic". Options are: \n${supportedScales.join('\n ')}`,
        example: "'launch-step -l major' or 'launch-step --scale=major'"
    },
    {
        name: 'root-note',
        short: 'n',
        type: 'string',
        description: `The note to start the scale from. Can be a MIDI note `
            + `number (0-127) or a note name like 'A1', 'Bb1' or 'C#1'. The `
            + `default is 'C4' (60).`,
        example: "'launch-step -n A4' or 'launch-step --root-note=A4'"
    },
]).run()

const options = {
    tempo : Number(args.options.tempo || 90),
    steps : args.options.steps || 8,
    rows  : args.options.rows || 8,
    scale : args.options.scale || 'major-pentatonic',
    root  : tonalMidi.toMidi(args.options['root-note'] || 60),
}

if (isNaN(options.root) || options.root == null) {
    console.error(`Invalid root note '${args.options['root-note']}' given`)
    process.exit(1)
}
if (!(supportedScales.includes(options.scale))) {
    console.error(`No scale named '${options.scale}', run 'launch-step --help' `
                  + `for a list of available scales.`)
    process.exit(1)
}
console.log(`Starting ${options.steps} step sequencer with ${options.rows} rows `
            + `at ${options.tempo} bpm using ${options.scale} scale starting with `
            + `${tonalMidi.fromMidi(options.root)}(${options.root}).`)

const midiInput = new midi.input()
const midiOutput = new midi.output()

midiInput.openVirtualPort('launch-step input')
midiOutput.openVirtualPort('launch-step output')

const state = {
    noteRows : getNoteRows(options.scale, options.root, options.rows),
    stepGrid : emptyStepGrid(),
    step     : 0,
    row      : 0,
    duration : 400, //ms
    moveViewDown: function () {
        this.row += 8
        if (this.row >= options.rows) {
            this.row = Math.floor((this.row - options.rows) / 8)
        }
    },
    moveViewUp: function () {
        this.row -= 8
        if (this.row < 0) {
            this.row = options.rows + this.row
        }
    },
    getOffsets: function() {
        return [Math.floor(this.step / 8) * 8, Math.floor(this.row / 8) * 8]
    }
}

const stepSequencer = new StepSequencer(options.tempo, options.steps, state.stepGrid)


//undefined = auto-connect, false = disable animation
const connection = midiLaunchpad.connect(undefined, false)

connection.on('ready', launchpad => {

    function render() {
        state.stepGrid[state.step].forEach((down, index) => {
            if (down) {
                midiOutput.sendMessage(noteOn(state.noteRows[index], 127))
                setTimeout(() => {
                    midiOutput.sendMessage(noteOff(state.noteRows[index], 127))
                }, state.duration)
            }
        })
        const canvas = emptyGrid(8, 8, '0')
        const [offsetX, offsetY] = state.getOffsets()
        const step = state.step - offsetX
        const page = state.stepGrid.slice(offsetX, offsetX + 8)
            .map(column => column.slice(offsetY, offsetY + 8))
        canvas.forEach((row, y) => {
            page.forEach((values, x) => {
                row[x] = values[y] ? 'g' : '0'
            })
        })
        canvas.forEach((row, y) => {
            row[step] = page[step][y] ? 'r' : 'y'
        })
        const level = offsetY / 8
        const color = level ? 'r' : '0'
        canvas.push([color, color])
        launchpad.renderBytes(canvas.map(a => a.join('')))
    }

    state.stepGrid.forEach((values, step) => {
        stepSequencer.on(step, () => {
            state.step = step
            render()
        })
    })

    launchpad.on('press', button => {
        if(!button.special) {
            const [offsetX, offsetY] = state.getOffsets()
            const x = button.x + offsetX
            const y = button.y + offsetY
            if (x < options.steps && y < options.rows) {
                state.stepGrid[x][y] = !state.stepGrid[x][y]
            }
        } else {
            switch(button.special[0]) {
                case 'mixer':
                    state.stepGrid = emptyStepGrid()
                    break
                case 'down':
                    state.moveViewDown()
                    break
                case 'up':
                    state.moveViewUp()
                    break
            }
        }
        render()
    })

    stepSequencer.play()

})

function getNoteRows(scaleKebab, rootNote, numberOfRows) {
    const name  = scaleFromKebab[scaleKebab]
    const tonal = tonalMidi.fromMidi(rootNote)
    const scale = tonalScale.build(name, tonal)
    const range = tonalRange.scaleRange(scale, `${rootNote} 127`)
    return range.slice(0, numberOfRows).map(tonalMidi.toMidi)
}

function emptyGrid(i, j, defaultValue) {
    return Array(i).fill().map(() => Array(j).fill(defaultValue))
}

function emptyStepGrid() {
    return emptyGrid(options.steps, 8, false)
}
