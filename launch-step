#!/usr/bin/env node
'use strict'
const midi          = require('midi')
const midiLaunchpad = require('midi-launchpad')
const argv          = require('argv')
const {red, green, orange, yellow, off} = midiLaunchpad.colors
const StepSequencer = require('step-sequencer')

const args = argv.option([
    {
        name: 'tempo',
        short: 't',
        type: 'string',
        description: 'Tempo in beats per minute. The default is 120. Can be set to "ext" to use an external midi clock signal.',
        example: "launch-step --tempo 133.2"
    },
    {
        name: 'steps',
        short: 's',
        type: 'int',
        description: 'Number of steps in the sequence. The default is 8.',
        example: "launch-step --steps 12"
    },
]).run()

const options = {tempo: 10, steps: 12, rows: 12}

const state = {
    stepGrid    : emptyStepGrid(),
    step        : 0,
    row         : 0,
    moveViewDown: () => {
        state.row += 8
        if (state.row >= options.rows) {
            state.row = Math.floor((state.row - options.rows) / 8)
        }
    },
    moveViewUp: () => {
        state.row -= 8
        if (state.row < 0) {
            state.row = options.rows + state.row
        }
    },
    getOffsets: () => [Math.floor(state.step / 8) * 8, Math.floor(state.row / 8) * 8]
}

const stepSequencer = new StepSequencer(options.tempo, options.steps, state.stepGrid)

//undefined = auto-connect, false = disable animation
const connection = midiLaunchpad.connect(undefined, false)

connection.on('ready', launchpad => {

    function render() {
        const canvas = emptyGrid(8, 8, '0')
        const [offsetX, offsetY] = state.getOffsets()
        const step = state.step - offsetX
        const page = state.stepGrid.slice(offsetX, offsetX + 8)
            .map(column => column.slice(offsetY, offsetY + 8))
        canvas.forEach((row, y) => {
            page.forEach((values, x) => {
                row[x] = values[y] ? 'g' : '0'
            })
        })
        canvas.forEach((row, y) => {
            row[step] = page[step][y] ? 'r' : 'y'
        })
        console.log(state.row)
        launchpad.renderBytes(canvas.map(a => a.join('')))
    }

    state.stepGrid.forEach((values, step) => {
        stepSequencer.on(step, () => {
            state.step = step
            render()
        })
    })

    launchpad.on('press', button => {
        if(!button.special) {
            const [offsetX, offsetY] = state.getOffsets()
            const x = button.x + offsetX
            const y = button.y + offsetY
            if (x < options.steps && y < options.rows) {
                state.stepGrid[x][y] = !state.stepGrid[x][y]
            }
        } else {
            console.log(button.special[0])
            switch(button.special[0]) {
                case 'mixer':
                    state.stepGrid = emptyStepGrid()
                    break
                case 'down':
                    state.moveViewDown()
                    break
                case 'up':
                    state.moveViewUp()
                    break
            }
        }
        render()
    })

    stepSequencer.play()

})

function emptyGrid(i, j, defaultValue) {
    return Array(i).fill().map(() => Array(j).fill(defaultValue))
}

function emptyStepGrid() {
    return emptyGrid(options.steps, 8, false)
}
